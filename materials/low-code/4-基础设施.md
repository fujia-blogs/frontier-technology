# 基础实施

1. web 组件库在三个环节发挥作用：

- 用于构建低代码编辑器自身；
- 构建编辑器的开发能力；
- 构建业务应用。

2. 编辑器的质量和能力基本决定了低代码平台的成败。

3. 好的组件库：

- 自主可控；

4. 低代码编辑器在 App 开发过程中对细节的管控程度，主要围绕配置量、难易度、适用范围，定制能力几个关键维度来分析：

|  细节管控  | 管控过严 | 管控过宽 |
| :--------: | :------: | :------: |
|   配置量   |    少    |    大    |
|  使用难度  |    低    |    高    |
| 可适用范围 |    窄    |    宽    |
|  定制能力  |    弱    |    强    |

5. 对 App 常用功能做组件化封装时一种非常合适的细节管控手段。

6. 过于啰嗦繁复的配置过程也导致无法做出复杂的应用来。

7. 编辑器的编辑过程，实际上就是在收集到开发者的配置信息之后，为组件的各个 API 生成正确值的过程。

8. **组件库的能力直接决定了低代码编辑器的开发能力。**

## UX 规范

**思考：我们公司目前在做的低代码下一步要做的就是，完善各种规范，其中就包括 UX 规范，说实话这种规范很容易被忽略。**

1. 技术面的问题是“看不见”的、是藏在“面子”后的“里子”。UX 规范是完全的“面子”，它必须要展示在低代码的业务开发者和 App 最终用户面前。

## 组件库

**一个重点：解决低代码编辑器的细节管控问题，如果组件集的封装程度不高，就达不到细节管控的目的。**

1. 自主性

集成第三方组件库的同时，可以开发一套公司自主的组件库。

2. 低代码编辑器使用的 Web 组件集称为可视化组件集：

- 封装程度高；

**建议：采用数据驱动的方式统一配置。这种模式的关键特征是组件将 HTML/CSS 彻底封装到其内部，只暴露出一些属性对外提供配置入口。** 这样的封装方式对低代码平台的代码生成器非常友好。

- 功能强大；

低代码编辑器的特点：

- 状态多；
- 形式多样；
- 功能丰富；
- 交互密集；
- 性能要求极高；

- 皮肤深度定制能力(可选)

1. 一个功能强大的组件库的特点：

- 组件集里至少包含 50 个以上的原子组件和容器类组件，才能基本覆盖完整日常所需；
- 具有良好的视图悬浮（气泡化）功能封装和多层视图叠加管理能力。低代码编辑器往往有密集的配置入口，许多配置项需要就地弹出气泡甚至多级气泡来承载，避免打断当前的开发工作；
- 数据采集类的组件（文本框、数字框、下拉选择等）必须对表单友好，这样才能更容易实现出表单类页面；
- 对常用功能要有统一封装，在 Angular 里称为指令 /Directive，特点是这些功能可以“外挂”到任何普通 dom 节点、组件节点上，实现功能扩展。比如，像任意视图下拉、上传功能、多功能徽标、下拉多级菜单、拖拽功能等功能都值得封装；
- 一个符号图标库，**这个建议配合 [阿里图标](https://www.iconfont.cn/)来管理一套自己的 SVG 图标库，使用第三方库很难满足业务。**

4. 组件集的性能要求，这个要求主要来自于低代码编辑器本身，以及所见即所得效果的实现方式。

低代码编辑器的复杂度非常高，特别是在画布界面，有各种各样的编辑器、配置界面、悬浮气泡、对话框等。活动视口（ViewPort）上同时有一两百活动组件都是家常便饭，这对组件的渲染性能和脏检查性能提出了很高的要求。

> tips： 对比 AppSmith，三四十个组件就有些卡顿了。

## 要点

1. 低代码的基础设施：组件集

组件集贯穿了基于 B/S 架构的低代码编辑器三个基本功能：

- 构建低代码编辑器自身；
- 构建编辑器的开发能力；
- 构建业务应用；

这些功能覆盖了低代码平台 60%~80% 的功能。

2. **组件集最好有一套 UX 规范，UX 规范对组件集和业务应用的“面子”有很大的影响。**

tips: UX 规范可以通盘接收大公司的规范或基于它们做一些定制化。

3. 技术积累是这一切一切的基础：一两位有深厚技术积累的领军人物是更重要的家底。
